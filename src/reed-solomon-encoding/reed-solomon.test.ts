import { describe, test, expect, it } from 'vitest';

import { createEncoding, type ReedSolomonEncodingOptions } from './reed-solomon.mts';
import { isEncoderError } from '../encoder-error.mts';
import { repeat, streamToString, stringToStream } from '../test-helpers';
import type { ReedSolomonEncoderError } from './reed-solomon.error.mts';

describe('reed‑solomon', () => {

  const defaultEncodingOptions: ReedSolomonEncodingOptions = {
    blockLength: 10,
    parityBytes: 4
  }

  it('should encode/decode properly', function () {

    const input = 'hello world';
    const inputStream = stringToStream(input)
    const rs = createEncoding(defaultEncodingOptions);
    const enc = rs.encode(inputStream) as Uint8Array;
    const dec = rs.decode(enc) as Uint8Array;

    expect(Array.from(enc)).toEqual([
      104, 101, 108, 108, 111, 32, 119,
      111, 114, 108, 100, 237, 37, 84,
      196, 253, 253, 137, 243, 168, 170
    ]);

    expect(streamToString(dec)).toEqual(input);

  });

  test('should correct errors properly', function () {

    const input = repeat(10, 'hello world ');
    const inputStream = stringToStream(input);
    const rs = createEncoding(defaultEncodingOptions);
    const enc = rs.encode(inputStream) as Uint8Array;

    expect(Array.from(enc)).toEqual([
      // 10 × "hello world " (120 bytes)
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 32,
      // 10 parity bytes (generated by the codec)
      40, 171, 40, 207, 45, 222, 68, 85, 45, 171
    ]);

    // Sanity-check
    let dec = rs.decode(enc) as Uint8Array
    expect(streamToString(dec)).toEqual(input);

    // Error correction should work
    enc[27] = 99;
    enc[enc.length - 4] = 99;
    enc[enc.length - 10] = 99;
    enc[7] = 99;
    enc[82] = 99;
    dec = rs.decode(enc) as Uint8Array
    expect(streamToString(dec)).toEqual(input);

    // Make it uncorrectable
    enc[83] = 99;
    enc[84] = 99;
    enc[85] = 99;
    enc[86] = 99;
    enc[87] = 99;
    enc[88] = 99;
    expect(isEncoderError(rs.decode(enc))).toBeTruthy();

  });

  test('should work with long input', function () {

    const input = repeat(300, 'Some very long string+')
    const inputStream = stringToStream(input)
    const rs = createEncoding(defaultEncodingOptions);
    const enc = rs.encode(inputStream) as Uint8Array;

    let dec = rs.decode(enc) as Uint8Array
    expect(streamToString(dec)).toEqual(input);

    enc[177] = 99;
    enc[2212] = 88;

    dec = rs.decode(enc) as Uint8Array
    expect(streamToString(dec)).toEqual(input);

  })

  // TODO generate a list of test values, test them here


  describe('encode/decode', () => {
    const payload = stringToStream('This is arbitrary text');
    const payloadBlockLength = payload.length + defaultEncodingOptions.parityBytes;

    test('encode returns Uint8Array on success', () => {

      const rs = createEncoding({ ...defaultEncodingOptions, blockLength: payloadBlockLength });
      const encodeResult = rs.encode(payload);
      expect(isEncoderError(encodeResult)).toBe(false);
      expect((encodeResult as Uint8Array).length).toBe(48);
    });

    test('encode returns DecodingError when parityBytes <= 0', () => {
      const rs = createEncoding({ parityBytes: 0, blockLength: payloadBlockLength });
      const encodeResult = rs.encode(payload);
      expect(isEncoderError(encodeResult)).toBe(true);
    });

    test('decode recovers original payload when no errors', () => {
      const rs = createEncoding({ ...defaultEncodingOptions, blockLength: payloadBlockLength });
      const encodeResult = rs.encode(payload) as Uint8Array;
      const decodeResult = rs.decode(encodeResult);
      expect(isEncoderError(decodeResult)).toBe(false);
      expect(Array.from(decodeResult as Uint8Array)).toEqual(Array.from(payload));
    });

    test('decode returns DecodingError when block length mismatches', () => {
      const rs = createEncoding({ parityBytes: 2, blockLength: payloadBlockLength });
      const wrongBlock = Uint8Array.from([0, 1, 2, 3]); // too short
      const decodeResult = rs.decode(wrongBlock);
      expect(isEncoderError(decodeResult)).toBe(true);
      expect((decodeResult as ReedSolomonEncoderError).message)
        .toBe('Decoded payload length (0) does not match expected (24)');
    });

    test('decode returns DecodingError when errors exceed correction capability', () => {
      const rs = createEncoding({ ...defaultEncodingOptions, blockLength: payloadBlockLength });
      const encodeResult = rs.encode(payload) as Uint8Array;
      // Flip 13 bytes – should be 2 to exceed correction (parityBytes/2 = 2)
      // However, it seems to need 13
      const corrupted = new Uint8Array(encodeResult.length);
      // It used test random, but because the size is this big we just erase the last 14 bytes
      corrupted.set(encodeResult.slice(0, encodeResult.length - 14))

      const decodeResult = rs.decode(corrupted);
      expect(isEncoderError(decodeResult)).toBe(true);
    });

  });
});